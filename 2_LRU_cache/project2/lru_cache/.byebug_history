c
key
c
key
c
key
c
key
c
key
c
link
c
link
c
link
c
link
c
link
c
link
c
link
c
link
c
link
c
@store.head.next.next.next
@store.head.next.next
@store.head.next
@store.head
@store.first
@store
@map
c
@store.head.key
self
@store.head.key
@store.head
c
@store
head
@store.head
@store
c
cc
c
@map[key]
c
@tail
@head.next.next.next.next
@head.next.next.next
@head.next.next
@head.next
self.each { |node| puts node.key }
@tail == @head
@tail
@head
c
current_link.prev
current_link.next
current_link
@head
current_link
@tail
c
@head
current_link
c
@tail
@head
current_link.prev
@head
current_link == @head
current_link == @tail
c
current_link.key
key
current_link.key == key
current_link == @head
current_link
current_link.prev
current_link
c
n
s
include?(key)
c
include?(key)
@store[key.hash % num_buckets].include?(key)
@store[key.hash % num_buckets]
[key.hash % num_buckets]
@store
@store.get(key)
key
@store.include?(key)
c
self[:one]
@store[:one]
val
key
c
@store[5]
@store[5].include?(key)
key.hash % num_buckets
key
@store[4]
@store[3].include?(key)
@store[3]
@store
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
val
key
c
key
@store[key.hash%num_buckets]
@store[key.hash%num_buckets].include?(key)
@store[3]
bucket
@store.include?(key)
c
bucket
@store.include?(key)
val
key
@store.first
@store
c
yield current_link
current_link.val
c
@head
c
@head
c
list
n
s
c
current_link.key == key
current_link == @head
@head == @tail
c
list
@head.key
@head
key
ke
c
key
c
current_link
c
self.last
c
self.last
@head
c
@store
@store[key.hash % num_buckets]
c
@store
key
c
num
c
1 % num_buckets
@count
[[]].hash
[].hash
@store
@store[key.hash % num_buckets].include?(key)
@store[key.hash % num_buckets].include(key)
@store[key.hash % num_buckets]
key
c
key
c
key
c
key
c
key
c
key
c
key
c
output ^= (index % el.hash)
output
n
s
n
s
n
exit
c
el
